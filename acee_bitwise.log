Testing inside file bitwise.s

Code Under Test
	PC: 26	bl    bitwise         
	PC: 0 	mov   r3  #0          
	PC: 1 	eor   r4  r0  r1      
	PC: 2 	and   r4  r4  #1      
	PC: 3 	cmp   r4  #0          
	PC: 4 	beq   res_not         
	PC: 5 	eor   r4  r4  #1      
	PC: 6 	b     s2              
	PC: 7 	mvn   r4  #1          
	PC: 8 	and   r3  r3  r4      
	PC: 9 	and   r4  r1  r0      
	PC: 10	and   r4  r4  #2      
	PC: 11	cmp   r4  #0          
	PC: 12	beq   resr            
	PC: 13	lsl   r3  r3  #2      
	PC: 14	b     s3              
	PC: 15	lsr   r3  r3  #2      
	PC: 16	orr   r4  r0  r1      
	PC: 17	and   r4  r4  #4      
	PC: 18	cmp   r4  #0          
	PC: 19	beq   end             
	PC: 20	eor   r3  r3  #15     
	PC: 21	mov   r0  r3          
	PC: 22	bx    lr              
	PC: 27	out   r0              
	PC: 28	ace_end               

====================   Iteration 1   ====================
Test Input: 
	r0 = 0
	r1 = 0

Coverage:
	Individual Coverage:	21/26 lines covered (80.7692%)
	Cumulative Coverage:	21/26 lines covered (80.7692%)
	PC: 26	bl    bitwise         X
	PC: 0 	mov   r3  #0          X
	PC: 1 	eor   r4  r0  r1      X
	PC: 2 	and   r4  r4  #1      X
	PC: 3 	cmp   r4  #0          X
	PC: 4 	beq   res_not         X
	PC: 5 	eor   r4  r4  #1      
	PC: 6 	b     s2              
	PC: 7 	mvn   r4  #1          X
	PC: 8 	and   r3  r3  r4      X
	PC: 9 	and   r4  r1  r0      X
	PC: 10	and   r4  r4  #2      X
	PC: 11	cmp   r4  #0          X
	PC: 12	beq   resr            X
	PC: 13	lsl   r3  r3  #2      
	PC: 14	b     s3              
	PC: 15	lsr   r3  r3  #2      X
	PC: 16	orr   r4  r0  r1      X
	PC: 17	and   r4  r4  #4      X
	PC: 18	cmp   r4  #0          X
	PC: 19	beq   end             X
	PC: 20	eor   r3  r3  #15     
	PC: 21	mov   r0  r3          X
	PC: 22	bx    lr              X
	PC: 27	out   r0              X
	PC: 28	ace_end               X

Path Constraints: 
	(let ((a!1 (+ (- 4294967296)
              (bv2int (bvxor ((_ int2bv 32) r0) ((_ int2bv 32) r1))))))
(let ((a!2 (ite (bvsle #x00000000 (bvxor ((_ int2bv 32) r0) ((_ int2bv 32) r1)))
                (bv2int (bvxor ((_ int2bv 32) r0) ((_ int2bv 32) r1)))
                a!1)))
(let ((a!3 (bvsle #x00000000
                  (concat #b0000000000000000000000000000000
                          ((_ extract 0 0) ((_ int2bv 32) a!2)))))
      (a!4 (+ (* 2 (bv2int #b0000000000000000000000000000000))
              (bv2int ((_ extract 0 0) ((_ int2bv 32) a!2)))))
      (a!5 (+ (- 4294967296)
              (* 2 (bv2int #b0000000000000000000000000000000))
              (bv2int ((_ extract 0 0) ((_ int2bv 32) a!2))))))
  (= (ite a!3 a!4 a!5) r0))))
	(let ((a!1 (bvnot (bvor (bvnot ((_ int2bv 32) r1)) (bvnot ((_ int2bv 32) r0))))))
(let ((a!2 ((_ int2bv 32)
             (ite (bvsle #x00000000 a!1)
                  (bv2int a!1)
                  (+ (- 4294967296) (bv2int a!1))))))
(let ((a!3 (+ (* 4 (bv2int #b000000000000000000000000000000))
              (* 2 (bv2int ((_ extract 1 1) a!2)))))
      (a!4 (+ (- 4294967296)
              (* 4 (bv2int #b000000000000000000000000000000))
              (* 2 (bv2int ((_ extract 1 1) a!2))))))
(let ((a!5 (ite (bvsle #x00000000
                       (concat #b000000000000000000000000000000
                               ((_ extract 1 1) a!2)
                               #b0))
                a!3
                a!4)))
  (= a!5 r0)))))
	(let ((a!1 (+ (- 4294967296)
              (bv2int (bvor ((_ int2bv 32) r0) ((_ int2bv 32) r1))))))
(let ((a!2 (ite (bvsle #x00000000 (bvor ((_ int2bv 32) r0) ((_ int2bv 32) r1)))
                (bv2int (bvor ((_ int2bv 32) r0) ((_ int2bv 32) r1)))
                a!1)))
(let ((a!3 (bvsle #x00000000
                  (concat #b00000000000000000000000000000
                          ((_ extract 2 2) ((_ int2bv 32) a!2))
                          #b00)))
      (a!4 (* 4 (bv2int ((_ extract 2 2) ((_ int2bv 32) a!2))))))
(let ((a!5 (ite a!3
                (+ (* 8 (bv2int #b00000000000000000000000000000)) a!4)
                (+ (- 4294967296)
                   (* 8 (bv2int #b00000000000000000000000000000))
                   a!4))))
  (= a!5 r0)))))

After doing path exploration, we will solve for path constraint: (ast-vector
  (let ((a!1 (+ (- 4294967296)
                (bv2int (bvxor ((_ int2bv 32) r0) ((_ int2bv 32) r1))))))
  (let ((a!2 (ite (bvsle #x00000000
                         (bvxor ((_ int2bv 32) r0) ((_ int2bv 32) r1)))
                  (bv2int (bvxor ((_ int2bv 32) r0) ((_ int2bv 32) r1)))
                  a!1)))
  (let ((a!3 (bvsle #x00000000
                    (concat #b0000000000000000000000000000000
                            ((_ extract 0 0) ((_ int2bv 32) a!2)))))
        (a!4 (+ (- 4294967296) (bv2int ((_ extract 0 0) ((_ int2bv 32) a!2))))))
  (let ((a!5 (ite a!3 (bv2int ((_ extract 0 0) ((_ int2bv 32) a!2))) a!4)))
    (= a!5 r0)))))
  (let ((a!1 (bvnot (bvor (bvnot ((_ int2bv 32) r1)) (bvnot ((_ int2bv 32) r0))))))
  (let ((a!2 ((_ int2bv 32)
               (ite (bvsle #x00000000 a!1)
                    (bv2int a!1)
                    (+ (- 4294967296) (bv2int a!1))))))
  (let ((a!3 (+ (- 4294967296) (* 2 (bv2int ((_ extract 1 1) a!2))))))
  (let ((a!4 (ite (bvsle #x00000000
                         (concat #b000000000000000000000000000000
                                 ((_ extract 1 1) a!2)
                                 #b0))
                  (* 2 (bv2int ((_ extract 1 1) a!2)))
                  a!3)))
    (= a!4 r0)))))
  (let ((a!1 (+ (- 4294967296)
                (bv2int (bvor ((_ int2bv 32) r0) ((_ int2bv 32) r1))))))
  (let ((a!2 (ite (bvsle #x00000000
                         (bvor ((_ int2bv 32) r0) ((_ int2bv 32) r1)))
                  (bv2int (bvor ((_ int2bv 32) r0) ((_ int2bv 32) r1)))
                  a!1)))
  (let ((a!3 (bvsle #x00000000
                    (concat #b00000000000000000000000000000
                            ((_ extract 2 2) ((_ int2bv 32) a!2))
                            #b00)))
        (a!4 (* 4 (bv2int ((_ extract 2 2) ((_ int2bv 32) a!2))))))
    (not (= (ite a!3 a!4 (+ (- 4294967296) a!4)) r0))))))
According to Z3, r0 does not have impact, we will pick safe value 0
According to Z3, r1 does not have impact, we will pick safe value 0
====================   Iteration 2   ====================
Test Input: 
	r0 = 0
	r1 = 0


 We discovered no new lines, we can end execution now



~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
 ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
Final Coverage: 21/26 lines covered (80.7692%)
	PC: 26	bl    bitwise         1 
	PC: 0 	mov   r3   #0         1 
	PC: 1 	eor   r4   r0   r1    1 
	PC: 2 	and   r4   r4   #1    1 
	PC: 3 	cmp   r4   #0         1 
	PC: 4 	beq   res_not         1 
	PC: 5 	eor   r4   r4   #1      
	PC: 6 	b     s2                
	PC: 7 	mvn   r4   #1         1 
	PC: 8 	and   r3   r3   r4    1 
	PC: 9 	and   r4   r1   r0    1 
	PC: 10	and   r4   r4   #2    1 
	PC: 11	cmp   r4   #0         1 
	PC: 12	beq   resr            1 
	PC: 13	lsl   r3   r3   #2      
	PC: 14	b     s3                
	PC: 15	lsr   r3   r3   #2    1 
	PC: 16	orr   r4   r0   r1    1 
	PC: 17	and   r4   r4   #4    1 
	PC: 18	cmp   r4   #0         1 
	PC: 19	beq   end             1 
	PC: 20	eor   r3   r3   #15     
	PC: 21	mov   r0   r3         1 
	PC: 22	bx    lr              1 
	PC: 27	out   r0              1 
	PC: 28	ace_end               1 

Final testcases:
r0=0      	r1=0      	

